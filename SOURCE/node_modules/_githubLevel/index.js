#! /usr/bin/env node
'use strict';
/******************************************************************************
  DEPENDENCIES = CUSTOM SDK [Custom Software Development Kit]
******************************************************************************/
var path    = require('path');
var minixhr = require('minixhr');
var levelup = require('levelup');
var leveljs = require('level-js');
// var version = require('level-version');
// // a version stream for a single key between versions 100 and 1000
// db.createVersionStream(key, {minVersion: 100, maxVersion: 1000}).pipe(/* ... */)
//
// // stream all keys, but only the most recent version of each
// db.createReadStream({versionLimit: 1}).pipe(/* ... */)
/******************************************************************************
  PARAMETER = ARGUMENT
******************************************************************************/
  // no cli tool
/******************************************************************************
  MODE
******************************************************************************/
  // just browser
/******************************************************************************
  MODULE INTERNALS & HELPERS
******************************************************************************/
var DBname  = location.href;
var db      = levelup(DBname, { db: leveljs });
// var db      = version(origin);
var logErr  = console.error.bind(console);
var logInfo = console.info.bind(console);

function levelGithub (parameter, callback) {
  // callback(error, data, version)
  if (!parameter || !callback) { return }


  var url = parameter.url || '';


  db.get(url, function (error, content, version) {
    content = validate(error, content);
    var request = {
      url         : url,
      headers     : {
        "If-None-Match"    : content.ETag || '',
        'X-Requested-With' :'XMLHttpRequest',
        'Content-Type'     :'application/x-www-form-urlencoded'
      }
    };
    minixhr(request, function (data, response, xhr, header) {
      var action = {
        200: success,
        304: unchanged,
        403: limitReached,
        404: notFound
      }[xhr.status];
      action ? action() : error();
      function success() {
        printRemaining(logInfo);
        data      = JSON.parse(data);
        var value = {
          ETag      : header.ETag,
          data      : data,
          url       : url
        };
        value = JSON.stringify(value);
        db.put(url, value, function (error, version) {
          if (error) {
            logErr('Could not store in IndexedDB');
            callback(null, data, null);
          } else {
            callback(null, data, version);
          }
        });
      }
      function unchanged () {
        printRemaining(logInfo);
        if (!content.data) {
          error();
        } else {
          callback(null, content.data, version);
        }
      }
      function printRemaining (logger) {
        var left  = +header["X-RateLimit-Remaining"];
        var total = +header["X-RateLimit-Limit"];
        var msg   = 'Remaining Requests: ' + left + '/' + total;
        logger(msg);
      }
      function notFound () {
        printRemaining(logErr);
        logErr(data);
        return
      }
      function limitReached () {
        printRemaining(logErr);
        notAvailable();
      }
      function error () {
        logErr('STATUS: ' + xhr.status);
        logErr('Something went wrong.');
      }
      function notAvailable () {
        var msg = 'Service temporarily not available - try again in one hour';
        // @TODO: maybe later a user can "sign in" with his gitub credentials
        // if that increases the API REQUEST Limit
        callback(new Error(msg));
      }
    });
  });
}
function clearDB () {
  indexedDB.webkitGetDatabaseNames().onsuccess = function(sender,args) {
    logInfo(sender.target.result);
    var result = sender.target.result;
    for(var length = result.length, idx=0;idx<length; idx++) {
      logInfo(result[idx]);
      if (result[idx] === DBname) {
        indexedDB.deleteDatabase(result[idx]).onsuccess = function () {
          logInfo(arguments);
        };
      }
    }
  };
}
function validate (error, content) {
  if (error && error.type !== 'NotFoundError') {
    throw error;
  } else if (error) {
    content = {};
  } else {
    content = JSON.parse(content);
  }
  return content;
}
levelGithub.clearDB = clearDB;
/******************************************************************************
  EXPORT
******************************************************************************/
module.exports = levelGithub;
